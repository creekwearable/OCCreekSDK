// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: enums.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Enums.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - EnumsRoot

@implementation EnumsRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - Enum operate_type

GPBEnumDescriptor *operate_type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Invalid\000Inquire\000Set\000";
    static const int32_t values[] = {
        operate_type_Invalid,
        operate_type_Inquire,
        operate_type_Set,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(operate_type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:operate_type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL operate_type_IsValidValue(int32_t value__) {
  switch (value__) {
    case operate_type_Invalid:
    case operate_type_Inquire:
    case operate_type_Set:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Platform

GPBEnumDescriptor *Platform_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Jx3085CPlatform\000Jx3085LPlatform\000Jx3085EP"
        "latform\000";
    static const int32_t values[] = {
        Platform_Jx3085CPlatform,
        Platform_Jx3085LPlatform,
        Platform_Jx3085EPlatform,
    };
    static const char *extraTextFormatInfo = "\003\000b\205\350\000\001b\205\350\000\002b\205\350\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Platform)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Platform_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Platform_IsValidValue(int32_t value__) {
  switch (value__) {
    case Platform_Jx3085CPlatform:
    case Platform_Jx3085LPlatform:
    case Platform_Jx3085EPlatform:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Shape

GPBEnumDescriptor *Shape_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SquareShape\000RoundShape\000";
    static const int32_t values[] = {
        Shape_SquareShape,
        Shape_RoundShape,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Shape)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Shape_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Shape_IsValidValue(int32_t value__) {
  switch (value__) {
    case Shape_SquareShape:
    case Shape_RoundShape:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum tran_direction_type

GPBEnumDescriptor *tran_direction_type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "WatchTran\000AppTran\000";
    static const int32_t values[] = {
        tran_direction_type_WatchTran,
        tran_direction_type_AppTran,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(tran_direction_type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:tran_direction_type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL tran_direction_type_IsValidValue(int32_t value__) {
  switch (value__) {
    case tran_direction_type_WatchTran:
    case tran_direction_type_AppTran:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Dev_type

GPBEnumDescriptor *Dev_type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "WatchType\000BandType\000";
    static const int32_t values[] = {
        Dev_type_WatchType,
        Dev_type_BandType,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Dev_type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Dev_type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Dev_type_IsValidValue(int32_t value__) {
  switch (value__) {
    case Dev_type_WatchType:
    case Dev_type_BandType:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Batt_mode

GPBEnumDescriptor *Batt_mode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "InvalidMode\000NormalMode\000EcoMode\000";
    static const int32_t values[] = {
        Batt_mode_InvalidMode,
        Batt_mode_NormalMode,
        Batt_mode_EcoMode,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Batt_mode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Batt_mode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Batt_mode_IsValidValue(int32_t value__) {
  switch (value__) {
    case Batt_mode_InvalidMode:
    case Batt_mode_NormalMode:
    case Batt_mode_EcoMode:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Batt_status

GPBEnumDescriptor *Batt_status_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Normal\000Charing\000Full\000Low\000";
    static const int32_t values[] = {
        Batt_status_Normal,
        Batt_status_Charing,
        Batt_status_Full,
        Batt_status_Low,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Batt_status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Batt_status_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Batt_status_IsValidValue(int32_t value__) {
  switch (value__) {
    case Batt_status_Normal:
    case Batt_status_Charing:
    case Batt_status_Full:
    case Batt_status_Low:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum disp_status

GPBEnumDescriptor *disp_status_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "DispOff\000DispOn\000";
    static const int32_t values[] = {
        disp_status_DispOff,
        disp_status_DispOn,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(disp_status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:disp_status_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL disp_status_IsValidValue(int32_t value__) {
  switch (value__) {
    case disp_status_DispOff:
    case disp_status_DispOn:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum alarm_type

GPBEnumDescriptor *alarm_type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "GetUp\000Sleep\000";
    static const int32_t values[] = {
        alarm_type_GetUp,
        alarm_type_Sleep,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(alarm_type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:alarm_type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL alarm_type_IsValidValue(int32_t value__) {
  switch (value__) {
    case alarm_type_GetUp:
    case alarm_type_Sleep:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum bind_method

GPBEnumDescriptor *bind_method_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "BindEncrypted\000BindNormal\000BindRemove\000Bind"
        "PairingCode\000";
    static const int32_t values[] = {
        bind_method_BindEncrypted,
        bind_method_BindNormal,
        bind_method_BindRemove,
        bind_method_BindPairingCode,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(bind_method)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:bind_method_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL bind_method_IsValidValue(int32_t value__) {
  switch (value__) {
    case bind_method_BindEncrypted:
    case bind_method_BindNormal:
    case bind_method_BindRemove:
    case bind_method_BindPairingCode:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum bind_flag

GPBEnumDescriptor *bind_flag_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "BindFlagRequest\000BindFlagFailed\000BindFlagS"
        "uccess\000BindFlagBound\000";
    static const int32_t values[] = {
        bind_flag_BindFlagRequest,
        bind_flag_BindFlagFailed,
        bind_flag_BindFlagSuccess,
        bind_flag_BindFlagBound,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(bind_flag)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:bind_flag_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL bind_flag_IsValidValue(int32_t value__) {
  switch (value__) {
    case bind_flag_BindFlagRequest:
    case bind_flag_BindFlagFailed:
    case bind_flag_BindFlagSuccess:
    case bind_flag_BindFlagBound:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum bind_phone_type

GPBEnumDescriptor *bind_phone_type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Android\000Ios\000";
    static const int32_t values[] = {
        bind_phone_type_Android,
        bind_phone_type_Ios,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(bind_phone_type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:bind_phone_type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL bind_phone_type_IsValidValue(int32_t value__) {
  switch (value__) {
    case bind_phone_type_Android:
    case bind_phone_type_Ios:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum call_status

GPBEnumDescriptor *call_status_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ReceivedCall\000RejectCall\000";
    static const int32_t values[] = {
        call_status_ReceivedCall,
        call_status_RejectCall,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(call_status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:call_status_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL call_status_IsValidValue(int32_t value__) {
  switch (value__) {
    case call_status_ReceivedCall:
    case call_status_RejectCall:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum quick_card_type

GPBEnumDescriptor *quick_card_type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CardTypeExercise\000CardTypeWeather\000CardTyp"
        "eSuggest\000CardTypeDial\000CardTypeActivity\000C"
        "ardTypeHeartrate\000CardTypeSleep\000CardTypeS"
        "teps\000CardTypeSpo2\000CardTypeMenstruation\000C"
        "ardTypeMeasurement\000CardTypeRecentWorkout"
        "\000CardTypeHrv\000CardTypeUv\000CardTypeAstronom"
        "y\000CardTypeWorldClock\000CardTypeAlexa\000";
    static const int32_t values[] = {
        quick_card_type_CardTypeExercise,
        quick_card_type_CardTypeWeather,
        quick_card_type_CardTypeSuggest,
        quick_card_type_CardTypeDial,
        quick_card_type_CardTypeActivity,
        quick_card_type_CardTypeHeartrate,
        quick_card_type_CardTypeSleep,
        quick_card_type_CardTypeSteps,
        quick_card_type_CardTypeSpo2,
        quick_card_type_CardTypeMenstruation,
        quick_card_type_CardTypeMeasurement,
        quick_card_type_CardTypeRecentWorkout,
        quick_card_type_CardTypeHrv,
        quick_card_type_CardTypeUv,
        quick_card_type_CardTypeAstronomy,
        quick_card_type_CardTypeWorldClock,
        quick_card_type_CardTypeAlexa,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(quick_card_type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:quick_card_type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL quick_card_type_IsValidValue(int32_t value__) {
  switch (value__) {
    case quick_card_type_CardTypeExercise:
    case quick_card_type_CardTypeWeather:
    case quick_card_type_CardTypeSuggest:
    case quick_card_type_CardTypeDial:
    case quick_card_type_CardTypeActivity:
    case quick_card_type_CardTypeHeartrate:
    case quick_card_type_CardTypeSleep:
    case quick_card_type_CardTypeSteps:
    case quick_card_type_CardTypeSpo2:
    case quick_card_type_CardTypeMenstruation:
    case quick_card_type_CardTypeMeasurement:
    case quick_card_type_CardTypeRecentWorkout:
    case quick_card_type_CardTypeHrv:
    case quick_card_type_CardTypeUv:
    case quick_card_type_CardTypeAstronomy:
    case quick_card_type_CardTypeWorldClock:
    case quick_card_type_CardTypeAlexa:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum sync_type

GPBEnumDescriptor *sync_type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SyncHeartRate\000SyncStress\000SyncSpo2\000SyncSl"
        "eep\000SyncWorkout\000SyncActivity\000SyncSwimmin"
        "g\000SyncGps\000SyncNoise\000SyncBodyEnergy\000SyncR"
        "espiratoryRate\000SyncSkinTemperature\000";
    static const int32_t values[] = {
        sync_type_SyncHeartRate,
        sync_type_SyncStress,
        sync_type_SyncSpo2,
        sync_type_SyncSleep,
        sync_type_SyncWorkout,
        sync_type_SyncActivity,
        sync_type_SyncSwimming,
        sync_type_SyncGps,
        sync_type_SyncNoise,
        sync_type_SyncBodyEnergy,
        sync_type_SyncRespiratoryRate,
        sync_type_SyncSkinTemperature,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(sync_type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:sync_type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL sync_type_IsValidValue(int32_t value__) {
  switch (value__) {
    case sync_type_SyncHeartRate:
    case sync_type_SyncStress:
    case sync_type_SyncSpo2:
    case sync_type_SyncSleep:
    case sync_type_SyncWorkout:
    case sync_type_SyncActivity:
    case sync_type_SyncSwimming:
    case sync_type_SyncGps:
    case sync_type_SyncNoise:
    case sync_type_SyncBodyEnergy:
    case sync_type_SyncRespiratoryRate:
    case sync_type_SyncSkinTemperature:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum sync_operate

GPBEnumDescriptor *sync_operate_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "StartSync\000EndSync\000";
    static const int32_t values[] = {
        sync_operate_StartSync,
        sync_operate_EndSync,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(sync_operate)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:sync_operate_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL sync_operate_IsValidValue(int32_t value__) {
  switch (value__) {
    case sync_operate_StartSync:
    case sync_operate_EndSync:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum language

GPBEnumDescriptor *language_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "LangInvalid\000Chinese\000English\000German\000Spani"
        "sh\000Italian\000Japanese\000Russian\000Portuguese\000F"
        "rench\000Korean\000Polish\000Czech\000Slovak\000Hungari"
        "an\000Greek\000Lithuanian\000Latvian\000Estonian\000Bul"
        "garian\000Malay\000Indonesian\000Thailand\000Vietnam"
        "ese\000Hebrew\000Devanagari\000Turkey\000";
    static const int32_t values[] = {
        language_LangInvalid,
        language_Chinese,
        language_English,
        language_German,
        language_Spanish,
        language_Italian,
        language_Japanese,
        language_Russian,
        language_Portuguese,
        language_French,
        language_Korean,
        language_Polish,
        language_Czech,
        language_Slovak,
        language_Hungarian,
        language_Greek,
        language_Lithuanian,
        language_Latvian,
        language_Estonian,
        language_Bulgarian,
        language_Malay,
        language_Indonesian,
        language_Thailand,
        language_Vietnamese,
        language_Hebrew,
        language_Devanagari,
        language_Turkey,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(language)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:language_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL language_IsValidValue(int32_t value__) {
  switch (value__) {
    case language_LangInvalid:
    case language_Chinese:
    case language_English:
    case language_German:
    case language_Spanish:
    case language_Italian:
    case language_Japanese:
    case language_Russian:
    case language_Portuguese:
    case language_French:
    case language_Korean:
    case language_Polish:
    case language_Czech:
    case language_Slovak:
    case language_Hungarian:
    case language_Greek:
    case language_Lithuanian:
    case language_Latvian:
    case language_Estonian:
    case language_Bulgarian:
    case language_Malay:
    case language_Indonesian:
    case language_Thailand:
    case language_Vietnamese:
    case language_Hebrew:
    case language_Devanagari:
    case language_Turkey:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum log_operate_type

GPBEnumDescriptor *log_operate_type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "LogStart\000LogEnd\000";
    static const int32_t values[] = {
        log_operate_type_LogStart,
        log_operate_type_LogEnd,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(log_operate_type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:log_operate_type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL log_operate_type_IsValidValue(int32_t value__) {
  switch (value__) {
    case log_operate_type_LogStart:
    case log_operate_type_LogEnd:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum period_log

GPBEnumDescriptor *period_log_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PeriodLogNull\000PeriodLogNotFlow\000PeriodLog"
        "AsUsual\000PeriodLogLightFlow\000PeriodLogMend"
        "iumFlow\000PeriodLogHeavyFlow\000";
    static const int32_t values[] = {
        period_log_PeriodLogNull,
        period_log_PeriodLogNotFlow,
        period_log_PeriodLogAsUsual,
        period_log_PeriodLogLightFlow,
        period_log_PeriodLogMendiumFlow,
        period_log_PeriodLogHeavyFlow,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(period_log)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:period_log_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL period_log_IsValidValue(int32_t value__) {
  switch (value__) {
    case period_log_PeriodLogNull:
    case period_log_PeriodLogNotFlow:
    case period_log_PeriodLogAsUsual:
    case period_log_PeriodLogLightFlow:
    case period_log_PeriodLogMendiumFlow:
    case period_log_PeriodLogHeavyFlow:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum notify_type

GPBEnumDescriptor *notify_type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Allow\000Silent\000Close\000";
    static const int32_t values[] = {
        notify_type_Allow,
        notify_type_Silent,
        notify_type_Close,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(notify_type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:notify_type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL notify_type_IsValidValue(int32_t value__) {
  switch (value__) {
    case notify_type_Allow:
    case notify_type_Silent:
    case notify_type_Close:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum health_monitor_mode

GPBEnumDescriptor *health_monitor_mode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Manual\000Auto\000Continuous\000Intellihent\000";
    static const int32_t values[] = {
        health_monitor_mode_Manual,
        health_monitor_mode_Auto,
        health_monitor_mode_Continuous,
        health_monitor_mode_Intellihent,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(health_monitor_mode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:health_monitor_mode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL health_monitor_mode_IsValidValue(int32_t value__) {
  switch (value__) {
    case health_monitor_mode_Manual:
    case health_monitor_mode_Auto:
    case health_monitor_mode_Continuous:
    case health_monitor_mode_Intellihent:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum health_type

GPBEnumDescriptor *health_type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "HeartRate\000Stress\000Spo2\000Noise\000BodyEnergy\000R"
        "espiratoryRate\000SkinTemperature\000";
    static const int32_t values[] = {
        health_type_HeartRate,
        health_type_Stress,
        health_type_Spo2,
        health_type_Noise,
        health_type_BodyEnergy,
        health_type_RespiratoryRate,
        health_type_SkinTemperature,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(health_type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:health_type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL health_type_IsValidValue(int32_t value__) {
  switch (value__) {
    case health_type_HeartRate:
    case health_type_Stress:
    case health_type_Spo2:
    case health_type_Noise:
    case health_type_BodyEnergy:
    case health_type_RespiratoryRate:
    case health_type_SkinTemperature:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum music_status

GPBEnumDescriptor *music_status_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MusicStatusInvalid\000MusicStatusPlay\000Music"
        "StatusPause\000";
    static const int32_t values[] = {
        music_status_MusicStatusInvalid,
        music_status_MusicStatusPlay,
        music_status_MusicStatusPause,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(music_status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:music_status_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL music_status_IsValidValue(int32_t value__) {
  switch (value__) {
    case music_status_MusicStatusInvalid:
    case music_status_MusicStatusPlay:
    case music_status_MusicStatusPause:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum operate_II_type

GPBEnumDescriptor *operate_II_type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Insert\000Delete\000Update\000Read\000";
    static const int32_t values[] = {
        operate_II_type_Insert,
        operate_II_type_Delete,
        operate_II_type_Update,
        operate_II_type_Read,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(operate_II_type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:operate_II_type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL operate_II_type_IsValidValue(int32_t value__) {
  switch (value__) {
    case operate_II_type_Insert:
    case operate_II_type_Delete:
    case operate_II_type_Update:
    case operate_II_type_Read:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum sensor_operate_type

GPBEnumDescriptor *sensor_operate_type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SensorTranStart\000SensorTranEnd\000OffLineTra"
        "nStart\000OffLineTranEnd\000";
    static const int32_t values[] = {
        sensor_operate_type_SensorTranStart,
        sensor_operate_type_SensorTranEnd,
        sensor_operate_type_OffLineTranStart,
        sensor_operate_type_OffLineTranEnd,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(sensor_operate_type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:sensor_operate_type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL sensor_operate_type_IsValidValue(int32_t value__) {
  switch (value__) {
    case sensor_operate_type_SensorTranStart:
    case sensor_operate_type_SensorTranEnd:
    case sensor_operate_type_OffLineTranStart:
    case sensor_operate_type_OffLineTranEnd:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum sleep_monitor_type

GPBEnumDescriptor *sleep_monitor_type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "General\000Science\000";
    static const int32_t values[] = {
        sleep_monitor_type_General,
        sleep_monitor_type_Science,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(sleep_monitor_type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:sleep_monitor_type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL sleep_monitor_type_IsValidValue(int32_t value__) {
  switch (value__) {
    case sleep_monitor_type_General:
    case sleep_monitor_type_Science:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum sport_type

GPBEnumDescriptor *sport_type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Orun\000Irun\000Owalk\000Iwalk\000Hiking\000Ocycle\000Icyc"
        "le\000Cricket\000Football\000Pswim\000Oswim\000Yoga\000Pil"
        "ates\000Dance\000Zumba\000Rower\000Elliptical\000Ctrain"
        "ing\000Tstraining\000Fstraining\000Hiit\000Cooldown\000"
        "Workout\000Fitness\000TrailRunning\000Treadmill\000A"
        "erobics\000SitUp\000Plank\000JumpingJack\000ChinUp\000P"
        "ushUp\000DeepSquat\000HighKneeLift\000Dumbbell\000Ba"
        "rbell\000Boxing\000Kickboxing\000HorizontalBar\000Pa"
        "rallelBars\000WalkingMachine\000SummitTrainers"
        "\000Bowling\000Tennis\000TableTennis\000Golf\000Basketb"
        "all\000Badminton\000Hockey\000Rugby\000Handball\000Squa"
        "sh\000Baseball\000Softball\000Shuttlecock\000Sepakta"
        "kraw\000StreetDance\000MountainClinbing\000RopeSk"
        "ipping\000ClimbStairs\000Ballet\000SocialDance\000Da"
        "rts\000HorsebackRiding\000RollerSkating\000TaiChi"
        "\000Frisbee\000HulaHoop\000Sleigh\000Skating\000Bobslei"
        "ghAndTobogganing\000Curling\000IceHockey\000Surfi"
        "ng\000Sailboat\000Sailboard\000Foldboating\000Canoei"
        "ng\000BoatRace\000Motorboat\000WaterPolo\000SlidingP"
        "late\000RockClimbing\000BungeeJumping\000Parkour\000"
        "Other\000Spinning\000MartialArts\000Taekwondo\000Kar"
        "ate\000Gymnastics\000Padel\000Pickleball\000Snowboar"
        "ding\000Skiing\000Paddling\000Bmx\000Fencing\000Billiar"
        "ds\000BeachSoccer\000BeachVolleyball\000Dodgeball"
        "\000Jazz\000Latin\000SquareDance\000Volleyball\000KiteF"
        "lying\000Fishing\000Archery\000Shooting\000WhiteWate"
        "rRafting\000AlpineSkiing\000CrossCountrySkiing"
        "\000Biathon\000DragonBoatRacing\000Racing\000";
    static const int32_t values[] = {
        sport_type_Orun,
        sport_type_Irun,
        sport_type_Owalk,
        sport_type_Iwalk,
        sport_type_Hiking,
        sport_type_Ocycle,
        sport_type_Icycle,
        sport_type_Cricket,
        sport_type_Football,
        sport_type_Pswim,
        sport_type_Oswim,
        sport_type_Yoga,
        sport_type_Pilates,
        sport_type_Dance,
        sport_type_Zumba,
        sport_type_Rower,
        sport_type_Elliptical,
        sport_type_Ctraining,
        sport_type_Tstraining,
        sport_type_Fstraining,
        sport_type_Hiit,
        sport_type_Cooldown,
        sport_type_Workout,
        sport_type_Fitness,
        sport_type_TrailRunning,
        sport_type_Treadmill,
        sport_type_Aerobics,
        sport_type_SitUp,
        sport_type_Plank,
        sport_type_JumpingJack,
        sport_type_ChinUp,
        sport_type_PushUp,
        sport_type_DeepSquat,
        sport_type_HighKneeLift,
        sport_type_Dumbbell,
        sport_type_Barbell,
        sport_type_Boxing,
        sport_type_Kickboxing,
        sport_type_HorizontalBar,
        sport_type_ParallelBars,
        sport_type_WalkingMachine,
        sport_type_SummitTrainers,
        sport_type_Bowling,
        sport_type_Tennis,
        sport_type_TableTennis,
        sport_type_Golf,
        sport_type_Basketball,
        sport_type_Badminton,
        sport_type_Hockey,
        sport_type_Rugby,
        sport_type_Handball,
        sport_type_Squash,
        sport_type_Baseball,
        sport_type_Softball,
        sport_type_Shuttlecock,
        sport_type_Sepaktakraw,
        sport_type_StreetDance,
        sport_type_MountainClinbing,
        sport_type_RopeSkipping,
        sport_type_ClimbStairs,
        sport_type_Ballet,
        sport_type_SocialDance,
        sport_type_Darts,
        sport_type_HorsebackRiding,
        sport_type_RollerSkating,
        sport_type_TaiChi,
        sport_type_Frisbee,
        sport_type_HulaHoop,
        sport_type_Sleigh,
        sport_type_Skating,
        sport_type_BobsleighAndTobogganing,
        sport_type_Curling,
        sport_type_IceHockey,
        sport_type_Surfing,
        sport_type_Sailboat,
        sport_type_Sailboard,
        sport_type_Foldboating,
        sport_type_Canoeing,
        sport_type_BoatRace,
        sport_type_Motorboat,
        sport_type_WaterPolo,
        sport_type_SlidingPlate,
        sport_type_RockClimbing,
        sport_type_BungeeJumping,
        sport_type_Parkour,
        sport_type_Other,
        sport_type_Spinning,
        sport_type_MartialArts,
        sport_type_Taekwondo,
        sport_type_Karate,
        sport_type_Gymnastics,
        sport_type_Padel,
        sport_type_Pickleball,
        sport_type_Snowboarding,
        sport_type_Skiing,
        sport_type_Paddling,
        sport_type_Bmx,
        sport_type_Fencing,
        sport_type_Billiards,
        sport_type_BeachSoccer,
        sport_type_BeachVolleyball,
        sport_type_Dodgeball,
        sport_type_Jazz,
        sport_type_Latin,
        sport_type_SquareDance,
        sport_type_Volleyball,
        sport_type_KiteFlying,
        sport_type_Fishing,
        sport_type_Archery,
        sport_type_Shooting,
        sport_type_WhiteWaterRafting,
        sport_type_AlpineSkiing,
        sport_type_CrossCountrySkiing,
        sport_type_Biathon,
        sport_type_DragonBoatRacing,
        sport_type_Racing,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(sport_type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:sport_type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL sport_type_IsValidValue(int32_t value__) {
  switch (value__) {
    case sport_type_Orun:
    case sport_type_Irun:
    case sport_type_Owalk:
    case sport_type_Iwalk:
    case sport_type_Hiking:
    case sport_type_Ocycle:
    case sport_type_Icycle:
    case sport_type_Cricket:
    case sport_type_Football:
    case sport_type_Pswim:
    case sport_type_Oswim:
    case sport_type_Yoga:
    case sport_type_Pilates:
    case sport_type_Dance:
    case sport_type_Zumba:
    case sport_type_Rower:
    case sport_type_Elliptical:
    case sport_type_Ctraining:
    case sport_type_Tstraining:
    case sport_type_Fstraining:
    case sport_type_Hiit:
    case sport_type_Cooldown:
    case sport_type_Workout:
    case sport_type_Fitness:
    case sport_type_TrailRunning:
    case sport_type_Treadmill:
    case sport_type_Aerobics:
    case sport_type_SitUp:
    case sport_type_Plank:
    case sport_type_JumpingJack:
    case sport_type_ChinUp:
    case sport_type_PushUp:
    case sport_type_DeepSquat:
    case sport_type_HighKneeLift:
    case sport_type_Dumbbell:
    case sport_type_Barbell:
    case sport_type_Boxing:
    case sport_type_Kickboxing:
    case sport_type_HorizontalBar:
    case sport_type_ParallelBars:
    case sport_type_WalkingMachine:
    case sport_type_SummitTrainers:
    case sport_type_Bowling:
    case sport_type_Tennis:
    case sport_type_TableTennis:
    case sport_type_Golf:
    case sport_type_Basketball:
    case sport_type_Badminton:
    case sport_type_Hockey:
    case sport_type_Rugby:
    case sport_type_Handball:
    case sport_type_Squash:
    case sport_type_Baseball:
    case sport_type_Softball:
    case sport_type_Shuttlecock:
    case sport_type_Sepaktakraw:
    case sport_type_StreetDance:
    case sport_type_MountainClinbing:
    case sport_type_RopeSkipping:
    case sport_type_ClimbStairs:
    case sport_type_Ballet:
    case sport_type_SocialDance:
    case sport_type_Darts:
    case sport_type_HorsebackRiding:
    case sport_type_RollerSkating:
    case sport_type_TaiChi:
    case sport_type_Frisbee:
    case sport_type_HulaHoop:
    case sport_type_Sleigh:
    case sport_type_Skating:
    case sport_type_BobsleighAndTobogganing:
    case sport_type_Curling:
    case sport_type_IceHockey:
    case sport_type_Surfing:
    case sport_type_Sailboat:
    case sport_type_Sailboard:
    case sport_type_Foldboating:
    case sport_type_Canoeing:
    case sport_type_BoatRace:
    case sport_type_Motorboat:
    case sport_type_WaterPolo:
    case sport_type_SlidingPlate:
    case sport_type_RockClimbing:
    case sport_type_BungeeJumping:
    case sport_type_Parkour:
    case sport_type_Other:
    case sport_type_Spinning:
    case sport_type_MartialArts:
    case sport_type_Taekwondo:
    case sport_type_Karate:
    case sport_type_Gymnastics:
    case sport_type_Padel:
    case sport_type_Pickleball:
    case sport_type_Snowboarding:
    case sport_type_Skiing:
    case sport_type_Paddling:
    case sport_type_Bmx:
    case sport_type_Fencing:
    case sport_type_Billiards:
    case sport_type_BeachSoccer:
    case sport_type_BeachVolleyball:
    case sport_type_Dodgeball:
    case sport_type_Jazz:
    case sport_type_Latin:
    case sport_type_SquareDance:
    case sport_type_Volleyball:
    case sport_type_KiteFlying:
    case sport_type_Fishing:
    case sport_type_Archery:
    case sport_type_Shooting:
    case sport_type_WhiteWaterRafting:
    case sport_type_AlpineSkiing:
    case sport_type_CrossCountrySkiing:
    case sport_type_Biathon:
    case sport_type_DragonBoatRacing:
    case sport_type_Racing:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum interval_division_mode

GPBEnumDescriptor *interval_division_mode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MaximumMode\000ReserveMode\000";
    static const int32_t values[] = {
        interval_division_mode_MaximumMode,
        interval_division_mode_ReserveMode,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(interval_division_mode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:interval_division_mode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL interval_division_mode_IsValidValue(int32_t value__) {
  switch (value__) {
    case interval_division_mode_MaximumMode:
    case interval_division_mode_ReserveMode:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum gender_type

GPBEnumDescriptor *gender_type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "GenderMale\000GenderFemale\000GenderOther\000";
    static const int32_t values[] = {
        gender_type_GenderMale,
        gender_type_GenderFemale,
        gender_type_GenderOther,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(gender_type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:gender_type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL gender_type_IsValidValue(int32_t value__) {
  switch (value__) {
    case gender_type_GenderMale:
    case gender_type_GenderFemale:
    case gender_type_GenderOther:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum dial_type

GPBEnumDescriptor *dial_type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "DialTypeNull\000DialTypeGeneral\000DialTypePho"
        "to\000DialTypeWallpaper\000DialTypeCustom\000Dial"
        "TypeGeneralAod\000DialTypeAod\000";
    static const int32_t values[] = {
        dial_type_DialTypeNull,
        dial_type_DialTypeGeneral,
        dial_type_DialTypePhoto,
        dial_type_DialTypeWallpaper,
        dial_type_DialTypeCustom,
        dial_type_DialTypeGeneralAod,
        dial_type_DialTypeAod,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(dial_type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:dial_type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL dial_type_IsValidValue(int32_t value__) {
  switch (value__) {
    case dial_type_DialTypeNull:
    case dial_type_DialTypeGeneral:
    case dial_type_DialTypePhoto:
    case dial_type_DialTypeWallpaper:
    case dial_type_DialTypeCustom:
    case dial_type_DialTypeGeneralAod:
    case dial_type_DialTypeAod:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum dial_operate_type

GPBEnumDescriptor *dial_operate_type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "DialOperateTypeInquire\000DialOperateTypeSe"
        "t\000DialOperateTypeDelete\000";
    static const int32_t values[] = {
        dial_operate_type_DialOperateTypeInquire,
        dial_operate_type_DialOperateTypeSet,
        dial_operate_type_DialOperateTypeDelete,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(dial_operate_type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:dial_operate_type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL dial_operate_type_IsValidValue(int32_t value__) {
  switch (value__) {
    case dial_operate_type_DialOperateTypeInquire:
    case dial_operate_type_DialOperateTypeSet:
    case dial_operate_type_DialOperateTypeDelete:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum weather_type

GPBEnumDescriptor *weather_type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Tornado\000TropicalStorm\000Hurricane\000StrongSt"
        "orms\000Thunderstorms\000RainSnow\000RainSleet\000Wi"
        "ntryMix\000FreezingDrizzle\000Drizzle\000Freezing"
        "Rain\000Showers\000Rain\000Flurries\000SnowShowers\000D"
        "riftingSnow\000Snow\000Hail\000Sleet\000BlowingDustS"
        "andstorm\000Foggy\000Haze\000Smoke\000Breezy\000Windy\000I"
        "ceCrystals\000Cloudy\000MostlyCloudyNight\000Most"
        "lyCloudyDay\000PartlyCloudyNight\000PartlyClou"
        "dyDay\000Clear\000Sunny\000MostlyClear\000MostlySunn"
        "y\000MixedRainHail\000Hot\000IsolatedThunderstorm"
        "s\000ScatteredThunderstormsD\000ScatteredShowe"
        "rsNight\000HeavyRain\000ScatteredSnowShowersD\000"
        "HeavySnow\000Blizzard\000NotAvailable\000Scattere"
        "dSnowShowersN\000ScatteredShowers\000Scattered"
        "ThunderstormsN\000";
    static const int32_t values[] = {
        weather_type_Tornado,
        weather_type_TropicalStorm,
        weather_type_Hurricane,
        weather_type_StrongStorms,
        weather_type_Thunderstorms,
        weather_type_RainSnow,
        weather_type_RainSleet,
        weather_type_WintryMix,
        weather_type_FreezingDrizzle,
        weather_type_Drizzle,
        weather_type_FreezingRain,
        weather_type_Showers,
        weather_type_Rain,
        weather_type_Flurries,
        weather_type_SnowShowers,
        weather_type_DriftingSnow,
        weather_type_Snow,
        weather_type_Hail,
        weather_type_Sleet,
        weather_type_BlowingDustSandstorm,
        weather_type_Foggy,
        weather_type_Haze,
        weather_type_Smoke,
        weather_type_Breezy,
        weather_type_Windy,
        weather_type_IceCrystals,
        weather_type_Cloudy,
        weather_type_MostlyCloudyNight,
        weather_type_MostlyCloudyDay,
        weather_type_PartlyCloudyNight,
        weather_type_PartlyCloudyDay,
        weather_type_Clear,
        weather_type_Sunny,
        weather_type_MostlyClear,
        weather_type_MostlySunny,
        weather_type_MixedRainHail,
        weather_type_Hot,
        weather_type_IsolatedThunderstorms,
        weather_type_ScatteredThunderstormsD,
        weather_type_ScatteredShowersNight,
        weather_type_HeavyRain,
        weather_type_ScatteredSnowShowersD,
        weather_type_HeavySnow,
        weather_type_Blizzard,
        weather_type_NotAvailable,
        weather_type_ScatteredSnowShowersN,
        weather_type_ScatteredShowers,
        weather_type_ScatteredThunderstormsN,
    };
    static const char *extraTextFormatInfo = "\001$b\001\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(weather_type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:weather_type_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL weather_type_IsValidValue(int32_t value__) {
  switch (value__) {
    case weather_type_Tornado:
    case weather_type_TropicalStorm:
    case weather_type_Hurricane:
    case weather_type_StrongStorms:
    case weather_type_Thunderstorms:
    case weather_type_RainSnow:
    case weather_type_RainSleet:
    case weather_type_WintryMix:
    case weather_type_FreezingDrizzle:
    case weather_type_Drizzle:
    case weather_type_FreezingRain:
    case weather_type_Showers:
    case weather_type_Rain:
    case weather_type_Flurries:
    case weather_type_SnowShowers:
    case weather_type_DriftingSnow:
    case weather_type_Snow:
    case weather_type_Hail:
    case weather_type_Sleet:
    case weather_type_BlowingDustSandstorm:
    case weather_type_Foggy:
    case weather_type_Haze:
    case weather_type_Smoke:
    case weather_type_Breezy:
    case weather_type_Windy:
    case weather_type_IceCrystals:
    case weather_type_Cloudy:
    case weather_type_MostlyCloudyNight:
    case weather_type_MostlyCloudyDay:
    case weather_type_PartlyCloudyNight:
    case weather_type_PartlyCloudyDay:
    case weather_type_Clear:
    case weather_type_Sunny:
    case weather_type_MostlyClear:
    case weather_type_MostlySunny:
    case weather_type_MixedRainHail:
    case weather_type_Hot:
    case weather_type_IsolatedThunderstorms:
    case weather_type_ScatteredThunderstormsD:
    case weather_type_ScatteredShowersNight:
    case weather_type_HeavyRain:
    case weather_type_ScatteredSnowShowersD:
    case weather_type_HeavySnow:
    case weather_type_Blizzard:
    case weather_type_NotAvailable:
    case weather_type_ScatteredSnowShowersN:
    case weather_type_ScatteredShowers:
    case weather_type_ScatteredThunderstormsN:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum wind_direction_type

GPBEnumDescriptor *wind_direction_type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "WeatherDirectionN\000WeatherDirectionNne\000We"
        "atherDirectionNe\000WeatherDirectionEne\000Wea"
        "therDirectionE\000WeatherDirectionEse\000Weath"
        "erDirectionSe\000WeatherDirectionSse\000Weathe"
        "rDirectionS\000WeatherDirectionSsw\000WeatherD"
        "irectionSw\000WeatherDirectionWsw\000WeatherDi"
        "rectionW\000WeatherDirectionWnwm\000WeatherDir"
        "ectionNw\000WeatherDirectionNnw\000";
    static const int32_t values[] = {
        wind_direction_type_WeatherDirectionN,
        wind_direction_type_WeatherDirectionNne,
        wind_direction_type_WeatherDirectionNe,
        wind_direction_type_WeatherDirectionEne,
        wind_direction_type_WeatherDirectionE,
        wind_direction_type_WeatherDirectionEse,
        wind_direction_type_WeatherDirectionSe,
        wind_direction_type_WeatherDirectionSse,
        wind_direction_type_WeatherDirectionS,
        wind_direction_type_WeatherDirectionSsw,
        wind_direction_type_WeatherDirectionSw,
        wind_direction_type_WeatherDirectionWsw,
        wind_direction_type_WeatherDirectionW,
        wind_direction_type_WeatherDirectionWnwm,
        wind_direction_type_WeatherDirectionNw,
        wind_direction_type_WeatherDirectionNnw,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(wind_direction_type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:wind_direction_type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL wind_direction_type_IsValidValue(int32_t value__) {
  switch (value__) {
    case wind_direction_type_WeatherDirectionN:
    case wind_direction_type_WeatherDirectionNne:
    case wind_direction_type_WeatherDirectionNe:
    case wind_direction_type_WeatherDirectionEne:
    case wind_direction_type_WeatherDirectionE:
    case wind_direction_type_WeatherDirectionEse:
    case wind_direction_type_WeatherDirectionSe:
    case wind_direction_type_WeatherDirectionSse:
    case wind_direction_type_WeatherDirectionS:
    case wind_direction_type_WeatherDirectionSsw:
    case wind_direction_type_WeatherDirectionSw:
    case wind_direction_type_WeatherDirectionWsw:
    case wind_direction_type_WeatherDirectionW:
    case wind_direction_type_WeatherDirectionWnwm:
    case wind_direction_type_WeatherDirectionNw:
    case wind_direction_type_WeatherDirectionNnw:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum moon_phase

GPBEnumDescriptor *moon_phase_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "NewMoon\000WaxingCrescent\000FirstQuarter\000Waxi"
        "ngGibbous\000FullMoon\000WaningGibbous\000LastQua"
        "rter\000WaningMoon\000";
    static const int32_t values[] = {
        moon_phase_NewMoon,
        moon_phase_WaxingCrescent,
        moon_phase_FirstQuarter,
        moon_phase_WaxingGibbous,
        moon_phase_FullMoon,
        moon_phase_WaningGibbous,
        moon_phase_LastQuarter,
        moon_phase_WaningMoon,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(moon_phase)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:moon_phase_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL moon_phase_IsValidValue(int32_t value__) {
  switch (value__) {
    case moon_phase_NewMoon:
    case moon_phase_WaxingCrescent:
    case moon_phase_FirstQuarter:
    case moon_phase_WaxingGibbous:
    case moon_phase_FullMoon:
    case moon_phase_WaningGibbous:
    case moon_phase_LastQuarter:
    case moon_phase_WaningMoon:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum message_remind_type

GPBEnumDescriptor *message_remind_type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Null\000Sms\000Email\000Calendar\000MissedCall\000Faceb"
        "ook\000Twitter\000Instagram\000Snapchat\000Whatsapp\000"
        "Line\000Tiktok\000Skype\000Wechat\000Fitbeing\000Micros"
        "oftTeams\000TelegramMessenger\000Messenger\000Lin"
        "kedIn\000Gmail\000MicrosoftOutlook\000GoogleChat\000"
        "Qq\000WhatsAppBusiness\000Youtube\000Uber\000UberEat"
        "s\000DoorDashMissing\000BancoGeneral\000BacBank\000G"
        "oogleMaps\000AmazonShopping\000Spotify\000Discord"
        "\000Ohter\000Dailyhunt\000FastrackSmartWorld\000Insh"
        "orts\000Ola\000Phonepe\000Swiggy\000Zomato\000Amazonpri"
        "me\000AmazonBusiness\000AmazonMusic\000Dunzo\000Zept"
        "o\000Flipkart\000Gaana\000GoogleDrive\000Gpay\000Hotsta"
        "r\000Netflix\000JioCinema\000Rapido\000DigiLocker\000My"
        "ntra\000UrbanCompany\000Paytm\000Wynk\000Yahoo\000Ytmus"
        "ic\000TitanSmartWorld\000MakeMyTrip\000JioTv\000";
    static const int32_t values[] = {
        message_remind_type_Null,
        message_remind_type_Sms,
        message_remind_type_Email,
        message_remind_type_Calendar,
        message_remind_type_MissedCall,
        message_remind_type_Facebook,
        message_remind_type_Twitter,
        message_remind_type_Instagram,
        message_remind_type_Snapchat,
        message_remind_type_Whatsapp,
        message_remind_type_Line,
        message_remind_type_Tiktok,
        message_remind_type_Skype,
        message_remind_type_Wechat,
        message_remind_type_Fitbeing,
        message_remind_type_MicrosoftTeams,
        message_remind_type_TelegramMessenger,
        message_remind_type_Messenger,
        message_remind_type_LinkedIn,
        message_remind_type_Gmail,
        message_remind_type_MicrosoftOutlook,
        message_remind_type_GoogleChat,
        message_remind_type_Qq,
        message_remind_type_WhatsAppBusiness,
        message_remind_type_Youtube,
        message_remind_type_Uber,
        message_remind_type_UberEats,
        message_remind_type_DoorDashMissing,
        message_remind_type_BancoGeneral,
        message_remind_type_BacBank,
        message_remind_type_GoogleMaps,
        message_remind_type_AmazonShopping,
        message_remind_type_Spotify,
        message_remind_type_Discord,
        message_remind_type_Ohter,
        message_remind_type_Dailyhunt,
        message_remind_type_FastrackSmartWorld,
        message_remind_type_Inshorts,
        message_remind_type_Ola,
        message_remind_type_Phonepe,
        message_remind_type_Swiggy,
        message_remind_type_Zomato,
        message_remind_type_Amazonprime,
        message_remind_type_AmazonBusiness,
        message_remind_type_AmazonMusic,
        message_remind_type_Dunzo,
        message_remind_type_Zepto,
        message_remind_type_Flipkart,
        message_remind_type_Gaana,
        message_remind_type_GoogleDrive,
        message_remind_type_Gpay,
        message_remind_type_Hotstar,
        message_remind_type_Netflix,
        message_remind_type_JioCinema,
        message_remind_type_Rapido,
        message_remind_type_DigiLocker,
        message_remind_type_Myntra,
        message_remind_type_UrbanCompany,
        message_remind_type_Paytm,
        message_remind_type_Wynk,
        message_remind_type_Yahoo,
        message_remind_type_Ytmusic,
        message_remind_type_TitanSmartWorld,
        message_remind_type_MakeMyTrip,
        message_remind_type_JioTv,
    };
    static const char *extraTextFormatInfo = " \002\005\000\003\010\000\004\006\204\000\005\010\000\006\007\000\007\t\000\010\010\000\t\010\000\n\004\000\013\006\000\014\005\000\r\006\000\016\010\000\017\t\205\000\020\010\211\000\021\t\000\022\010\000\023\005\000\024\t\207\000\025\006\204\000\027\010\210\000\030\007\000\031\004\000\032\004\244\000\033\004\204\247\000\034\005\207\000\035c\204\000\036\006\204\000\037\006\250\000 \007\000!\007\000@\003\342\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(message_remind_type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:message_remind_type_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL message_remind_type_IsValidValue(int32_t value__) {
  switch (value__) {
    case message_remind_type_Null:
    case message_remind_type_Sms:
    case message_remind_type_Email:
    case message_remind_type_Calendar:
    case message_remind_type_MissedCall:
    case message_remind_type_Facebook:
    case message_remind_type_Twitter:
    case message_remind_type_Instagram:
    case message_remind_type_Snapchat:
    case message_remind_type_Whatsapp:
    case message_remind_type_Line:
    case message_remind_type_Tiktok:
    case message_remind_type_Skype:
    case message_remind_type_Wechat:
    case message_remind_type_Fitbeing:
    case message_remind_type_MicrosoftTeams:
    case message_remind_type_TelegramMessenger:
    case message_remind_type_Messenger:
    case message_remind_type_LinkedIn:
    case message_remind_type_Gmail:
    case message_remind_type_MicrosoftOutlook:
    case message_remind_type_GoogleChat:
    case message_remind_type_Qq:
    case message_remind_type_WhatsAppBusiness:
    case message_remind_type_Youtube:
    case message_remind_type_Uber:
    case message_remind_type_UberEats:
    case message_remind_type_DoorDashMissing:
    case message_remind_type_BancoGeneral:
    case message_remind_type_BacBank:
    case message_remind_type_GoogleMaps:
    case message_remind_type_AmazonShopping:
    case message_remind_type_Spotify:
    case message_remind_type_Discord:
    case message_remind_type_Ohter:
    case message_remind_type_Dailyhunt:
    case message_remind_type_FastrackSmartWorld:
    case message_remind_type_Inshorts:
    case message_remind_type_Ola:
    case message_remind_type_Phonepe:
    case message_remind_type_Swiggy:
    case message_remind_type_Zomato:
    case message_remind_type_Amazonprime:
    case message_remind_type_AmazonBusiness:
    case message_remind_type_AmazonMusic:
    case message_remind_type_Dunzo:
    case message_remind_type_Zepto:
    case message_remind_type_Flipkart:
    case message_remind_type_Gaana:
    case message_remind_type_GoogleDrive:
    case message_remind_type_Gpay:
    case message_remind_type_Hotstar:
    case message_remind_type_Netflix:
    case message_remind_type_JioCinema:
    case message_remind_type_Rapido:
    case message_remind_type_DigiLocker:
    case message_remind_type_Myntra:
    case message_remind_type_UrbanCompany:
    case message_remind_type_Paytm:
    case message_remind_type_Wynk:
    case message_remind_type_Yahoo:
    case message_remind_type_Ytmusic:
    case message_remind_type_TitanSmartWorld:
    case message_remind_type_MakeMyTrip:
    case message_remind_type_JioTv:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum notify_os_platform

GPBEnumDescriptor *notify_os_platform_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AndroidNotify\000IosNotify\000";
    static const int32_t values[] = {
        notify_os_platform_AndroidNotify,
        notify_os_platform_IosNotify,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(notify_os_platform)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:notify_os_platform_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL notify_os_platform_IsValidValue(int32_t value__) {
  switch (value__) {
    case notify_os_platform_AndroidNotify:
    case notify_os_platform_IosNotify:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum aod_mode

GPBEnumDescriptor *aod_mode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "IntelligentMode\000TimerMdoe\000";
    static const int32_t values[] = {
        aod_mode_IntelligentMode,
        aod_mode_TimerMdoe,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(aod_mode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:aod_mode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL aod_mode_IsValidValue(int32_t value__) {
  switch (value__) {
    case aod_mode_IntelligentMode:
    case aod_mode_TimerMdoe:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum event_id

GPBEnumDescriptor *event_id_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "EventIdNull\000EventIdMusicControl\000EventIdF"
        "indPhone\000EventIdSyncData\000EventIdFindWatc"
        "h\000EventIdVolumeChange\000";
    static const int32_t values[] = {
        event_id_EventIdNull,
        event_id_EventIdMusicControl,
        event_id_EventIdFindPhone,
        event_id_EventIdSyncData,
        event_id_EventIdFindWatch,
        event_id_EventIdVolumeChange,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(event_id)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:event_id_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL event_id_IsValidValue(int32_t value__) {
  switch (value__) {
    case event_id_EventIdNull:
    case event_id_EventIdMusicControl:
    case event_id_EventIdFindPhone:
    case event_id_EventIdSyncData:
    case event_id_EventIdFindWatch:
    case event_id_EventIdVolumeChange:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum long_2s_press_type

GPBEnumDescriptor *long_2s_press_type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PressTypeNull\000PressTypeSos\000PressTypeWork"
        "out\000PressTypeAlexa\000";
    static const int32_t values[] = {
        long_2s_press_type_PressTypeNull,
        long_2s_press_type_PressTypeSos,
        long_2s_press_type_PressTypeWorkout,
        long_2s_press_type_PressTypeAlexa,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(long_2s_press_type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:long_2s_press_type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL long_2s_press_type_IsValidValue(int32_t value__) {
  switch (value__) {
    case long_2s_press_type_PressTypeNull:
    case long_2s_press_type_PressTypeSos:
    case long_2s_press_type_PressTypeWorkout:
    case long_2s_press_type_PressTypeAlexa:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum app_list

GPBEnumDescriptor *app_list_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AppListActivity\000AppListWorkout\000AppListSt"
        "eps\000AppListHeartrate\000AppListSleep\000AppLis"
        "tStress\000AppListMenstruation\000AppListBreat"
        "he\000AppListAlarms\000AppListPhone\000AppListTim"
        "ers\000AppListStopwatch\000AppListSpo2\000AppList"
        "Weather\000AppListCameraRemote\000AppListMusic"
        "\000AppListFindPhone\000AppListWorldClock\000AppL"
        "istSettings\000";
    static const int32_t values[] = {
        app_list_AppListActivity,
        app_list_AppListWorkout,
        app_list_AppListSteps,
        app_list_AppListHeartrate,
        app_list_AppListSleep,
        app_list_AppListStress,
        app_list_AppListMenstruation,
        app_list_AppListBreathe,
        app_list_AppListAlarms,
        app_list_AppListPhone,
        app_list_AppListTimers,
        app_list_AppListStopwatch,
        app_list_AppListSpo2,
        app_list_AppListWeather,
        app_list_AppListCameraRemote,
        app_list_AppListMusic,
        app_list_AppListFindPhone,
        app_list_AppListWorldClock,
        app_list_AppListSettings,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(app_list)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:app_list_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL app_list_IsValidValue(int32_t value__) {
  switch (value__) {
    case app_list_AppListActivity:
    case app_list_AppListWorkout:
    case app_list_AppListSteps:
    case app_list_AppListHeartrate:
    case app_list_AppListSleep:
    case app_list_AppListStress:
    case app_list_AppListMenstruation:
    case app_list_AppListBreathe:
    case app_list_AppListAlarms:
    case app_list_AppListPhone:
    case app_list_AppListTimers:
    case app_list_AppListStopwatch:
    case app_list_AppListSpo2:
    case app_list_AppListWeather:
    case app_list_AppListCameraRemote:
    case app_list_AppListMusic:
    case app_list_AppListFindPhone:
    case app_list_AppListWorldClock:
    case app_list_AppListSettings:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: enums.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers.h>
#else
 #import "GPBProtocolBuffers.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30004
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30004 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

CF_EXTERN_C_BEGIN

NS_ASSUME_NONNULL_BEGIN

#pragma mark - Enum operate_type

typedef GPB_ENUM(operate_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  operate_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  operate_type_Invalid = 0,

  /** query */
  operate_type_Inquire = 1,

  /** set */
  operate_type_Set = 2,
};

GPBEnumDescriptor *operate_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL operate_type_IsValidValue(int32_t value);

#pragma mark - Enum Platform

typedef GPB_ENUM(Platform) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  Platform_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  Platform_Jx3085CPlatform = 0,
  Platform_Jx3085LPlatform = 1,
  Platform_Jx3085EPlatform = 2,
  Platform_Jx3085SPlatform = 3,
};

GPBEnumDescriptor *Platform_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL Platform_IsValidValue(int32_t value);

#pragma mark - Enum Shape

typedef GPB_ENUM(Shape) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  Shape_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** square */
  Shape_SquareShape = 0,

  /** round shape */
  Shape_RoundShape = 1,
};

GPBEnumDescriptor *Shape_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL Shape_IsValidValue(int32_t value);

#pragma mark - Enum Dev_type

typedef GPB_ENUM(Dev_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  Dev_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Watch */
  Dev_type_WatchType = 0,

  /** bracelet */
  Dev_type_BandType = 1,
};

GPBEnumDescriptor *Dev_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL Dev_type_IsValidValue(int32_t value);

#pragma mark - Enum Batt_mode

typedef GPB_ENUM(Batt_mode) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  Batt_mode_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** invalid */
  Batt_mode_InvalidMode = 0,

  /** normal mode (not power saving mode) */
  Batt_mode_NormalMode = 1,

  /** power saving mode */
  Batt_mode_EcoMode = 2,
};

GPBEnumDescriptor *Batt_mode_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL Batt_mode_IsValidValue(int32_t value);

#pragma mark - Enum Batt_status

typedef GPB_ENUM(Batt_status) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  Batt_status_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** not charging */
  Batt_status_Normal = 0,

  /** charging */
  Batt_status_Charing = 1,

  /** full charge */
  Batt_status_Full = 2,

  /** low battery */
  Batt_status_Low = 3,
};

GPBEnumDescriptor *Batt_status_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL Batt_status_IsValidValue(int32_t value);

#pragma mark - Enum disp_status

typedef GPB_ENUM(disp_status) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  disp_status_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  disp_status_DispOff = 0,
  disp_status_DispOn = 1,
};

GPBEnumDescriptor *disp_status_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL disp_status_IsValidValue(int32_t value);

#pragma mark - Enum alarm_type

typedef GPB_ENUM(alarm_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  alarm_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** get up */
  alarm_type_GetUp = 0,

  /** sleep */
  alarm_type_Sleep = 1,
};

GPBEnumDescriptor *alarm_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL alarm_type_IsValidValue(int32_t value);

#pragma mark - Enum bind_method

typedef GPB_ENUM(bind_method) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  bind_method_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** authorization code verification */
  bind_method_BindEncrypted = 0,

  /** direct binding */
  bind_method_BindNormal = 1,

  /** Unbind */
  bind_method_BindRemove = 2,

  /** Pairing code binding */
  bind_method_BindPairingCode = 3,
};

GPBEnumDescriptor *bind_method_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL bind_method_IsValidValue(int32_t value);

#pragma mark - Enum bind_flag

typedef GPB_ENUM(bind_flag) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  bind_flag_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Represents request binding */
  bind_flag_BindFlagRequest = 0,

  /** Failed */
  bind_flag_BindFlagFailed = 1,

  /** success */
  bind_flag_BindFlagSuccess = 2,

  /** Bound */
  bind_flag_BindFlagBound = 3,
};

GPBEnumDescriptor *bind_flag_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL bind_flag_IsValidValue(int32_t value);

#pragma mark - Enum bind_phone_type

typedef GPB_ENUM(bind_phone_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  bind_phone_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Android */
  bind_phone_type_Android = 0,

  /** IOS phone */
  bind_phone_type_Ios = 1,
};

GPBEnumDescriptor *bind_phone_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL bind_phone_type_IsValidValue(int32_t value);

#pragma mark - Enum call_status

typedef GPB_ENUM(call_status) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  call_status_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** The incoming call has been answered */
  call_status_ReceivedCall = 0,

  /** The call has been rejected */
  call_status_RejectCall = 1,
};

GPBEnumDescriptor *call_status_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL call_status_IsValidValue(int32_t value);

#pragma mark - Enum quick_card_type

typedef GPB_ENUM(quick_card_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  quick_card_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  quick_card_type_CardTypeExercise = 0,
  quick_card_type_CardTypeWeather = 1,
  quick_card_type_CardTypeSuggest = 2,
  quick_card_type_CardTypeDial = 3,
  quick_card_type_CardTypeActivity = 4,
  quick_card_type_CardTypeHeartrate = 5,
  quick_card_type_CardTypeSleep = 6,

  /** Step counting */
  quick_card_type_CardTypeSteps = 7,
  quick_card_type_CardTypeSpo2 = 8,

  /** Female menstrual cycle */
  quick_card_type_CardTypeMenstruation = 9,

  /** One-click measurement (blood oxygen, heart rate, pressure) */
  quick_card_type_CardTypeMeasurement = 10,

  /** Trajectories and activities of the latest outdoor exercise */
  quick_card_type_CardTypeRecentWorkout = 11,
  quick_card_type_CardTypeHrv = 12,

  /** Ultraviolet */
  quick_card_type_CardTypeUv = 13,

  /** Moonrise, moonset, sunrise and sunset */
  quick_card_type_CardTypeAstronomy = 14,

  /** World clock */
  quick_card_type_CardTypeWorldClock = 15,

  /** alexa */
  quick_card_type_CardTypeAlexa = 16,
};

GPBEnumDescriptor *quick_card_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL quick_card_type_IsValidValue(int32_t value);

#pragma mark - Enum sync_type

typedef GPB_ENUM(sync_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  sync_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** heart rate */
  sync_type_SyncHeartRate = 0,

  /** pressure */
  sync_type_SyncStress = 1,

  /** blood oxygen */
  sync_type_SyncSpo2 = 2,

  /** sleep */
  sync_type_SyncSleep = 3,

  /** Motion data */
  sync_type_SyncWorkout = 4,

  /** Daily activity data */
  sync_type_SyncActivity = 5,

  /** swimming data */
  sync_type_SyncSwimming = 6,

  /** gps */
  sync_type_SyncGps = 7,

  /** noise */
  sync_type_SyncNoise = 8,

  /** body power */
  sync_type_SyncBodyEnergy = 9,

  /** Respiratory rate */
  sync_type_SyncRespiratoryRate = 10,

  /** skin temperature */
  sync_type_SyncSkinTemperature = 11,
};

GPBEnumDescriptor *sync_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL sync_type_IsValidValue(int32_t value);

#pragma mark - Enum sync_operate

typedef GPB_ENUM(sync_operate) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  sync_operate_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  sync_operate_StartSync = 0,
  sync_operate_EndSync = 1,
};

GPBEnumDescriptor *sync_operate_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL sync_operate_IsValidValue(int32_t value);

#pragma mark - Enum language

typedef GPB_ENUM(language) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  language_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Invalid */
  language_LangInvalid = 0,

  /** Chinese */
  language_Chinese = 1,

  /** English */
  language_English = 2,

  /** German */
  language_German = 3,

  /** Spanish */
  language_Spanish = 4,

  /** Italian */
  language_Italian = 5,

  /** Japanese */
  language_Japanese = 6,

  /** Russian */
  language_Russian = 7,

  /** Portuguese */
  language_Portuguese = 8,

  /** French */
  language_French = 9,

  /** Korean */
  language_Korean = 10,

  /** Polish */
  language_Polish = 11,

  /** Czech */
  language_Czech = 12,

  /** Slovak */
  language_Slovak = 13,

  /** Hungarian */
  language_Hungarian = 14,

  /** Greek */
  language_Greek = 15,

  /** Lithuanian */
  language_Lithuanian = 16,

  /** Latvian */
  language_Latvian = 17,

  /** Estonian */
  language_Estonian = 18,

  /** Bulgarian */
  language_Bulgarian = 19,

  /** Malay */
  language_Malay = 20,

  /** Indonesian */
  language_Indonesian = 21,

  /** Thailand */
  language_Thailand = 22,

  /** Vietnamese */
  language_Vietnamese = 23,

  /** Hebrew */
  language_Hebrew = 24,

  /** Devanagari */
  language_Devanagari = 25,

  /** Turkish */
  language_Turkey = 26,

  /** Romanian */
  language_Romanian = 27,

  /** Dutch */
  language_Dutch = 28,

  /** Ukrainian */
  language_Ukrainian = 29,

  /** Arabic */
  language_Arabic = 30,

  /** Persian */
  language_Farsi = 31,
};

GPBEnumDescriptor *language_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL language_IsValidValue(int32_t value);

#pragma mark - Enum log_operate_type

typedef GPB_ENUM(log_operate_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  log_operate_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  log_operate_type_LogStart = 0,
  log_operate_type_LogEnd = 1,
};

GPBEnumDescriptor *log_operate_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL log_operate_type_IsValidValue(int32_t value);

#pragma mark - Enum period_log

typedef GPB_ENUM(period_log) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  period_log_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** No record */
  period_log_PeriodLogNull = 0,

  /** No blood volume */
  period_log_PeriodLogNotFlow = 1,

  /** As usual */
  period_log_PeriodLogAsUsual = 2,

  /** Less blood volume */
  period_log_PeriodLogLightFlow = 3,

  /** Medium blood volume */
  period_log_PeriodLogMendiumFlow = 4,

  /** Large blood volume */
  period_log_PeriodLogHeavyFlow = 5,
};

GPBEnumDescriptor *period_log_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL period_log_IsValidValue(int32_t value);

#pragma mark - Enum notify_type

typedef GPB_ENUM(notify_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  notify_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Allow notifications */
  notify_type_Allow = 0,

  /** Silent notification */
  notify_type_Silent = 1,

  /** close notification */
  notify_type_Close = 2,
};

GPBEnumDescriptor *notify_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL notify_type_IsValidValue(int32_t value);

#pragma mark - Enum health_monitor_mode

typedef GPB_ENUM(health_monitor_mode) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  health_monitor_mode_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Manual */
  health_monitor_mode_Manual = 0,

  /** automatically */
  health_monitor_mode_Auto = 1,

  /** continuous monitoring */
  health_monitor_mode_Continuous = 2,

  /** intelligent monitoring */
  health_monitor_mode_Intellihent = 3,
};

GPBEnumDescriptor *health_monitor_mode_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL health_monitor_mode_IsValidValue(int32_t value);

#pragma mark - Enum health_type

typedef GPB_ENUM(health_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  health_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** heart rate */
  health_type_HeartRate = 0,

  /** pressure */
  health_type_Stress = 1,

  /** blood oxygen */
  health_type_Spo2 = 2,

  /** noise */
  health_type_Noise = 3,

  /** body power */
  health_type_BodyEnergy = 4,

  /** Respiratory rate */
  health_type_RespiratoryRate = 5,

  /** skin temperature */
  health_type_SkinTemperature = 6,
};

GPBEnumDescriptor *health_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL health_type_IsValidValue(int32_t value);

#pragma mark - Enum music_status

typedef GPB_ENUM(music_status) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  music_status_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** invalid */
  music_status_MusicStatusInvalid = 0,

  /** Play */
  music_status_MusicStatusPlay = 1,

  /** Pause */
  music_status_MusicStatusPause = 2,
};

GPBEnumDescriptor *music_status_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL music_status_IsValidValue(int32_t value);

#pragma mark - Enum operate_II_type

typedef GPB_ENUM(operate_II_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  operate_II_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** increase */
  operate_II_type_Insert = 0,

  /** delete */
  operate_II_type_Delete = 1,

  /** Change */
  operate_II_type_Update = 2,

  /** check */
  operate_II_type_Read = 3,
};

GPBEnumDescriptor *operate_II_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL operate_II_type_IsValidValue(int32_t value);

#pragma mark - Enum sensor_operate_type

typedef GPB_ENUM(sensor_operate_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  sensor_operate_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  sensor_operate_type_SensorTranStart = 0,
  sensor_operate_type_SensorTranEnd = 1,
  sensor_operate_type_OffLineTranStart = 2,
  sensor_operate_type_OffLineTranEnd = 3,
};

GPBEnumDescriptor *sensor_operate_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL sensor_operate_type_IsValidValue(int32_t value);

#pragma mark - Enum sleep_monitor_type

typedef GPB_ENUM(sleep_monitor_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  sleep_monitor_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** General sleep */
  sleep_monitor_type_General = 0,

  /** scientific sleep */
  sleep_monitor_type_Science = 1,
};

GPBEnumDescriptor *sleep_monitor_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL sleep_monitor_type_IsValidValue(int32_t value);

#pragma mark - Enum sport_type

typedef GPB_ENUM(sport_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  sport_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Outdoor running */
  sport_type_Orun = 0,

  /** Indoor running */
  sport_type_Irun = 1,

  /** Walking outdoors */
  sport_type_Owalk = 2,

  /** Indoor walking */
  sport_type_Iwalk = 3,

  /** Hiking */
  sport_type_Hiking = 4,

  /** Outdoor cycling */
  sport_type_Ocycle = 5,

  /** Indoor cycling */
  sport_type_Icycle = 6,

  /** cricket */
  sport_type_Cricket = 7,

  /** football */
  sport_type_Football = 8,

  /** Pool swimming */
  sport_type_Pswim = 9,

  /** Open area swimming */
  sport_type_Oswim = 10,

  /** Yoga */
  sport_type_Yoga = 11,

  /** Pilates */
  sport_type_Pilates = 12,

  /** Dance */
  sport_type_Dance = 13,

  /** Zumba dance */
  sport_type_Zumba = 14,

  /** rowing machine */
  sport_type_Rower = 15,

  /** elliptical machine */
  sport_type_Elliptical = 16,

  /** Core training */
  sport_type_Ctraining = 17,

  /** Traditional strength training */
  sport_type_Tstraining = 18,

  /** Functional strength training */
  sport_type_Fstraining = 19,

  /** HIIT */
  sport_type_Hiit = 20,

  /** Tidy up and relax */
  sport_type_Cooldown = 21,

  /** Free training */
  sport_type_Workout = 22,

  /** Fitness */
  sport_type_Fitness = 23,

  /** Trail running */
  sport_type_TrailRunning = 24,

  /** fitness */
  sport_type_Treadmill = 25,

  /** aerobics */
  sport_type_Aerobics = 26,

  /** Sit-ups */
  sport_type_SitUp = 27,

  /** Plank support */
  sport_type_Plank = 28,

  /** Jumping and jacking */
  sport_type_JumpingJack = 29,

  /** Pull-ups */
  sport_type_ChinUp = 30,

  /** Push-ups */
  sport_type_PushUp = 31,

  /** Squat */
  sport_type_DeepSquat = 32,

  /** raise legs high */
  sport_type_HighKneeLift = 33,

  /** dumbbell */
  sport_type_Dumbbell = 34,

  /** barbell */
  sport_type_Barbell = 35,

  /** boxing */
  sport_type_Boxing = 36,

  /** free fighting */
  sport_type_Kickboxing = 37,

  /** horizontal bar */
  sport_type_HorizontalBar = 38,

  /** parallel bars */
  sport_type_ParallelBars = 39,

  /** Walking machine */
  sport_type_WalkingMachine = 40,

  /** climbing machine */
  sport_type_SummitTrainers = 41,

  /** Balls */
  sport_type_Bowling = 42,

  /** tennis */
  sport_type_Tennis = 43,

  /** Table tennis */
  sport_type_TableTennis = 44,

  /** golf ball */
  sport_type_Golf = 45,

  /** Basketball */
  sport_type_Basketball = 46,

  /** Badminton */
  sport_type_Badminton = 47,

  /** Hockey */
  sport_type_Hockey = 48,

  /** rugby */
  sport_type_Rugby = 49,

  /** Handball */
  sport_type_Handball = 50,

  /** Squash */
  sport_type_Squash = 51,

  /** baseball */
  sport_type_Baseball = 52,

  /** softball */
  sport_type_Softball = 53,

  /** Shuttlecock */
  sport_type_Shuttlecock = 54,

  /** Sepak Takraw */
  sport_type_Sepaktakraw = 55,

  /** Leisure sport */
  sport_type_StreetDance = 56,

  /** Mounting */
  sport_type_MountainClinbing = 57,

  /** skipping rope */
  sport_type_RopeSkipping = 58,

  /** Climb stairs */
  sport_type_ClimbStairs = 59,

  /** Ballet */
  sport_type_Ballet = 60,

  /** Social dance */
  sport_type_SocialDance = 61,

  /** darts */
  sport_type_Darts = 62,

  /** Horse riding */
  sport_type_HorsebackRiding = 63,

  /** Roller skating */
  sport_type_RollerSkating = 64,

  /** Tai Chi */
  sport_type_TaiChi = 65,

  /** Frisbee */
  sport_type_Frisbee = 66,

  /** Hula hoop */
  sport_type_HulaHoop = 67,

  /** ice and snow sports */
  sport_type_Sleigh = 68,

  /** skating */
  sport_type_Skating = 69,

  /** Snowmobile */
  sport_type_BobsleighAndTobogganing = 70,

  /** curling */
  sport_type_Curling = 71,

  /** ice hockey */
  sport_type_IceHockey = 72,

  /** water sports */
  sport_type_Surfing = 73,

  /** Sailboat */
  sport_type_Sailboat = 74,

  /** Sailboard */
  sport_type_Sailboard = 75,

  /** Kayak */
  sport_type_Foldboating = 76,

  /** rowing boat */
  sport_type_Canoeing = 77,

  /** rowing */
  sport_type_BoatRace = 78,

  /** Motorboat */
  sport_type_Motorboat = 79,

  /** water polo */
  sport_type_WaterPolo = 80,

  /** Extreme sport */
  sport_type_SlidingPlate = 81,

  /** rock climbing */
  sport_type_RockClimbing = 82,

  /** Bungee jumping */
  sport_type_BungeeJumping = 83,

  /** Parkour */
  sport_type_Parkour = 84,

  /** Other */
  sport_type_Other = 85,

  /** Add new sports */
  sport_type_Spinning = 86,

  /** Martial Arts */
  sport_type_MartialArts = 87,

  /** Taekwondo */
  sport_type_Taekwondo = 88,

  /** Karate */
  sport_type_Karate = 89,

  /** gymnastics */
  sport_type_Gymnastics = 90,

  /** cage tennis */
  sport_type_Padel = 91,

  /** pickleball */
  sport_type_Pickleball = 92,

  /** Snowboarding */
  sport_type_Snowboarding = 93,

  /** Skiing */
  sport_type_Skiing = 94,

  /** Paddle */
  sport_type_Paddling = 95,

  /** BMX */
  sport_type_Bmx = 96,

  /** Fencing */
  sport_type_Fencing = 97,

  /** Billiards */
  sport_type_Billiards = 98,

  /** Beach Soccer */
  sport_type_BeachSoccer = 99,

  /** Beach volleyball */
  sport_type_BeachVolleyball = 100,

  /** Dodgeball */
  sport_type_Dodgeball = 101,

  /** Jazz dance */
  sport_type_Jazz = 102,

  /** Latin dance */
  sport_type_Latin = 103,

  /** Square dance */
  sport_type_SquareDance = 104,

  /** Volleyball */
  sport_type_Volleyball = 105,

  /** Kite flying */
  sport_type_KiteFlying = 106,

  /** Fishing */
  sport_type_Fishing = 107,

  /** Archery */
  sport_type_Archery = 108,

  /** shooting */
  sport_type_Shooting = 109,

  /** Rafting */
  sport_type_WhiteWaterRafting = 110,

  /** Alpine skiing */
  sport_type_AlpineSkiing = 111,

  /** cross-country skiing */
  sport_type_CrossCountrySkiing = 112,

  /** biathlon */
  sport_type_Biathon = 113,

  /** Dragon boat */
  sport_type_DragonBoatRacing = 114,

  /** racing */
  sport_type_Racing = 115,
};

GPBEnumDescriptor *sport_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL sport_type_IsValidValue(int32_t value);

#pragma mark - Enum interval_division_mode

typedef GPB_ENUM(interval_division_mode) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  interval_division_mode_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Maximum heart rate zone mode */
  interval_division_mode_MaximumMode = 0,

  /** Reserve heart rate interval mode */
  interval_division_mode_ReserveMode = 1,
};

GPBEnumDescriptor *interval_division_mode_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL interval_division_mode_IsValidValue(int32_t value);

#pragma mark - Enum gender_type

typedef GPB_ENUM(gender_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  gender_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** male */
  gender_type_GenderMale = 0,

  /** female */
  gender_type_GenderFemale = 1,

  /** other */
  gender_type_GenderOther = 2,
};

GPBEnumDescriptor *gender_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL gender_type_IsValidValue(int32_t value);

#pragma mark - Enum dial_type

typedef GPB_ENUM(dial_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  dial_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** invalid */
  dial_type_DialTypeNull = 0,

  /** General cloud dial */
  dial_type_DialTypeGeneral = 1,

  /** photo dial */
  dial_type_DialTypePhoto = 2,

  /** Wallpaper dial */
  dial_type_DialTypeWallpaper = 3,

  /** custom dial */
  dial_type_DialTypeCustom = 4,

  /** Normal dial + screen dial */
  dial_type_DialTypeGeneralAod = 5,

  /** Normal off-screen dial */
  dial_type_DialTypeAod = 6,
};

GPBEnumDescriptor *dial_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL dial_type_IsValidValue(int32_t value);

#pragma mark - Enum dial_operate_type

typedef GPB_ENUM(dial_operate_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  dial_operate_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** The query is using the dial */
  dial_operate_type_DialOperateTypeInquire = 0,

  /** Set the dial */
  dial_operate_type_DialOperateTypeSet = 1,

  /** Delete the dial */
  dial_operate_type_DialOperateTypeDelete = 2,
};

GPBEnumDescriptor *dial_operate_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL dial_operate_type_IsValidValue(int32_t value);

#pragma mark - Enum weather_type

typedef GPB_ENUM(weather_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  weather_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** tornado */
  weather_type_Tornado = 0,

  /** tropical storm */
  weather_type_TropicalStorm = 1,

  /** hurricane */
  weather_type_Hurricane = 2,

  /** Strong storms */
  weather_type_StrongStorms = 3,

  /** thunderstorms/thunderstorms */
  weather_type_Thunderstorms = 4,

  /** rain and snow */
  weather_type_RainSnow = 5,

  /** rain plus hail */
  weather_type_RainSleet = 6,

  /** mixed rainfall */
  weather_type_WintryMix = 7,

  /** freezing rain */
  weather_type_FreezingDrizzle = 8,

  /** drizzle */
  weather_type_Drizzle = 9,

  /** freezing rain */
  weather_type_FreezingRain = 10,

  /** showers */
  weather_type_Showers = 11,

  /** Rain */
  weather_type_Rain = 12,

  /** little snow */
  weather_type_Flurries = 13,

  /** Snow showers */
  weather_type_SnowShowers = 14,

  /** drifting snow (wind effect) */
  weather_type_DriftingSnow = 15,

  /** snow */
  weather_type_Snow = 16,

  /** hail */
  weather_type_Hail = 17,

  /** hail/freezing rain */
  weather_type_Sleet = 18,

  /** blowing dust/sandstorm */
  weather_type_BlowingDustSandstorm = 19,

  /** fog */
  weather_type_Foggy = 20,

  /** haze */
  weather_type_Haze = 21,

  /** smoke */
  weather_type_Smoke = 22,

  /** Breeze */
  weather_type_Breezy = 23,

  /** strong wind */
  weather_type_Windy = 24,

  /** cold current */
  weather_type_IceCrystals = 25,

  /** cloudy */
  weather_type_Cloudy = 26,

  /** cloudy and sunny (evening) */
  weather_type_MostlyCloudyNight = 27,

  /** cloudy and sunny (daytime) */
  weather_type_MostlyCloudyDay = 28,

  /** cloudy to sunny (evening) */
  weather_type_PartlyCloudyNight = 29,

  /** cloudy to sunny (daytime) */
  weather_type_PartlyCloudyDay = 30,

  /** Sunny day (evening) */
  weather_type_Clear = 31,

  /** Sunny day (day) */
  weather_type_Sunny = 32,

  /** clear and cloudy (evening) */
  weather_type_MostlyClear = 33,

  /** sunny and cloudy (daytime) */
  weather_type_MostlySunny = 34,

  /** rain plus hail */
  weather_type_MixedRainHail = 35,

  /** Hot */
  weather_type_Hot = 36,

  /** Partial thunderstorms */
  weather_type_IsolatedThunderstorms = 37,

  /** Partial thunderstorms (DAY) */
  weather_type_ScatteredThunderstormsD = 38,

  /** Scattered showers (Night) */
  weather_type_ScatteredShowersNight = 39,

  /** heavy rain */
  weather_type_HeavyRain = 40,

  /** Scattered snow showers */
  weather_type_ScatteredSnowShowersD = 41,

  /** Blizzard */
  weather_type_HeavySnow = 42,

  /** Blizzard */
  weather_type_Blizzard = 43,

  /** no data (unavailable) */
  weather_type_NotAvailable = 44,

  /** Scattered showers (Night) */
  weather_type_ScatteredSnowShowersN = 45,

  /** scattered snow showers */
  weather_type_ScatteredShowers = 46,

  /** Partial thunderstorms (Night) */
  weather_type_ScatteredThunderstormsN = 47,
};

GPBEnumDescriptor *weather_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL weather_type_IsValidValue(int32_t value);

#pragma mark - Enum wind_direction_type

/** wind direction */
typedef GPB_ENUM(wind_direction_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  wind_direction_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** true north */
  wind_direction_type_WeatherDirectionN = 0,

  /** North northeast */
  wind_direction_type_WeatherDirectionNne = 1,

  /** Northeast */
  wind_direction_type_WeatherDirectionNe = 2,

  /** East northeast */
  wind_direction_type_WeatherDirectionEne = 3,

  /** East */
  wind_direction_type_WeatherDirectionE = 4,

  /** East, southeast */
  wind_direction_type_WeatherDirectionEse = 5,

  /** southeast */
  wind_direction_type_WeatherDirectionSe = 6,

  /** south southeast */
  wind_direction_type_WeatherDirectionSse = 7,

  /** south */
  wind_direction_type_WeatherDirectionS = 8,

  /** South Southwest */
  wind_direction_type_WeatherDirectionSsw = 9,

  /** Southwest */
  wind_direction_type_WeatherDirectionSw = 10,

  /** West Southwest */
  wind_direction_type_WeatherDirectionWsw = 11,

  /** West */
  wind_direction_type_WeatherDirectionW = 12,

  /** West Northwest */
  wind_direction_type_WeatherDirectionWnwm = 13,

  /** Northwest */
  wind_direction_type_WeatherDirectionNw = 14,

  /** North and Northwest */
  wind_direction_type_WeatherDirectionNnw = 15,
};

GPBEnumDescriptor *wind_direction_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL wind_direction_type_IsValidValue(int32_t value);

#pragma mark - Enum moon_phase

typedef GPB_ENUM(moon_phase) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  moon_phase_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** New moon */
  moon_phase_NewMoon = 0,

  /** Emei Yue */
  moon_phase_WaxingCrescent = 1,

  /** First quarter moon */
  moon_phase_FirstQuarter = 2,

  /** Waxing gibbous moon */
  moon_phase_WaxingGibbous = 3,

  /** Full moon */
  moon_phase_FullMoon = 4,

  /** Wanthing gibbous moon */
  moon_phase_WaningGibbous = 5,

  /** Last quarter moon */
  moon_phase_LastQuarter = 6,

  /** waning moon */
  moon_phase_WaningMoon = 7,
};

GPBEnumDescriptor *moon_phase_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL moon_phase_IsValidValue(int32_t value);

#pragma mark - Enum message_remind_type

typedef GPB_ENUM(message_remind_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  message_remind_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  message_remind_type_Null = 0,
  message_remind_type_Sms = 1,
  message_remind_type_Email = 2,
  message_remind_type_Calendar = 3,
  message_remind_type_MissedCall = 4,
  message_remind_type_Facebook = 5,
  message_remind_type_Twitter = 6,
  message_remind_type_Instagram = 7,
  message_remind_type_Snapchat = 8,
  message_remind_type_Whatsapp = 9,
  message_remind_type_Line = 10,
  message_remind_type_Tiktok = 11,
  message_remind_type_Skype = 12,
  message_remind_type_Wechat = 13,
  message_remind_type_Fitbeing = 14,
  message_remind_type_MicrosoftTeams = 15,
  message_remind_type_TelegramMessenger = 16,
  message_remind_type_Messenger = 17,
  message_remind_type_LinkedIn = 18,
  message_remind_type_Gmail = 19,
  message_remind_type_MicrosoftOutlook = 20,
  message_remind_type_GoogleChat = 21,
  message_remind_type_Qq = 22,
  message_remind_type_WhatsAppBusiness = 23,
  message_remind_type_Youtube = 24,
  message_remind_type_Uber = 25,
  message_remind_type_UberEats = 26,
  message_remind_type_DoorDashMissing = 27,
  message_remind_type_BancoGeneral = 28,
  message_remind_type_BacBank = 29,
  message_remind_type_GoogleMaps = 30,
  message_remind_type_AmazonShopping = 31,
  message_remind_type_Spotify = 32,
  message_remind_type_Discord = 33,

  /** ohter */
  message_remind_type_Ohter = 34,
  message_remind_type_Dailyhunt = 35,
  message_remind_type_FastrackSmartWorld = 36,
  message_remind_type_Inshorts = 37,
  message_remind_type_Ola = 38,
  message_remind_type_Phonepe = 39,
  message_remind_type_Swiggy = 40,
  message_remind_type_Zomato = 41,
  message_remind_type_Amazonprime = 42,
  message_remind_type_AmazonBusiness = 43,
  message_remind_type_AmazonMusic = 44,
  message_remind_type_Dunzo = 45,
  message_remind_type_Zepto = 46,
  message_remind_type_Flipkart = 47,
  message_remind_type_Gaana = 48,
  message_remind_type_GoogleDrive = 49,
  message_remind_type_Gpay = 50,
  message_remind_type_Hotstar = 51,
  message_remind_type_Netflix = 52,
  message_remind_type_JioCinema = 53,
  message_remind_type_Rapido = 54,
  message_remind_type_DigiLocker = 55,
  message_remind_type_Myntra = 56,
  message_remind_type_UrbanCompany = 57,
  message_remind_type_Paytm = 58,
  message_remind_type_Wynk = 59,
  message_remind_type_Yahoo = 60,
  message_remind_type_Ytmusic = 61,
  message_remind_type_TitanSmartWorld = 62,
  message_remind_type_MakeMyTrip = 63,
  message_remind_type_JioTv = 64,
};

GPBEnumDescriptor *message_remind_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL message_remind_type_IsValidValue(int32_t value);

#pragma mark - Enum tran_direction_type

typedef GPB_ENUM(tran_direction_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  tran_direction_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Initiated by watch */
  tran_direction_type_WatchTran = 0,

  /** Initiated by app */
  tran_direction_type_AppTran = 1,
};

GPBEnumDescriptor *tran_direction_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL tran_direction_type_IsValidValue(int32_t value);

#pragma mark - Enum notify_os_platform

typedef GPB_ENUM(notify_os_platform) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  notify_os_platform_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Android */
  notify_os_platform_AndroidNotify = 0,
  notify_os_platform_IosNotify = 1,
};

GPBEnumDescriptor *notify_os_platform_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL notify_os_platform_IsValidValue(int32_t value);

#pragma mark - Enum aod_mode

typedef GPB_ENUM(aod_mode) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  aod_mode_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  aod_mode_IntelligentMode = 0,
  aod_mode_TimerMdoe = 1,
};

GPBEnumDescriptor *aod_mode_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL aod_mode_IsValidValue(int32_t value);

#pragma mark - Enum event_id

typedef GPB_ENUM(event_id) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  event_id_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  event_id_EventIdNull = 0,

  /** Music control */
  event_id_EventIdMusicControl = 1,

  /** Find phone */
  event_id_EventIdFindPhone = 2,

  /** Notify data update */
  event_id_EventIdSyncData = 3,

  /** Find watch */
  event_id_EventIdFindWatch = 4,

  /** Volume change (required by Alexa) */
  event_id_EventIdVolumeChange = 5,
};

GPBEnumDescriptor *event_id_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL event_id_IsValidValue(int32_t value);

#pragma mark - Enum long_2s_press_type

typedef GPB_ENUM(long_2s_press_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  long_2s_press_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  long_2s_press_type_PressTypeNull = 0,
  long_2s_press_type_PressTypeSos = 1,
  long_2s_press_type_PressTypeWorkout = 2,
  long_2s_press_type_PressTypeAlexa = 3,
};

GPBEnumDescriptor *long_2s_press_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL long_2s_press_type_IsValidValue(int32_t value);

#pragma mark - Enum app_list

typedef GPB_ENUM(app_list) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  app_list_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Activity */
  app_list_AppListActivity = 0,

  /** Sports */
  app_list_AppListWorkout = 1,

  /** Step counting */
  app_list_AppListSteps = 2,

  /** Heart rate */
  app_list_AppListHeartrate = 3,

  /** Sleep */
  app_list_AppListSleep = 4,

  /** Pressure */
  app_list_AppListStress = 5,

  /** Women’s Health */
  app_list_AppListMenstruation = 6,

  /** breathing training */
  app_list_AppListBreathe = 7,

  /** Alarm clock */
  app_list_AppListAlarms = 8,

  /** Phone */
  app_list_AppListPhone = 9,

  /** Countdown */
  app_list_AppListTimers = 10,

  /** Stopwatch */
  app_list_AppListStopwatch = 11,

  /** blood oxygen */
  app_list_AppListSpo2 = 12,

  /** Weather */
  app_list_AppListWeather = 13,

  /** Camera control */
  app_list_AppListCameraRemote = 14,

  /** Music control */
  app_list_AppListMusic = 15,

  /** Find mobile phone */
  app_list_AppListFindPhone = 16,

  /** World clock */
  app_list_AppListWorldClock = 17,

  /** Settings */
  app_list_AppListSettings = 18,
};

GPBEnumDescriptor *app_list_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL app_list_IsValidValue(int32_t value);

#pragma mark - Enum msg_send_type

typedef GPB_ENUM(msg_send_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  msg_send_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Send from watch */
  msg_send_type_WatchMsgSend = 0,

  /** App reply */
  msg_send_type_AppMsgReply = 1,
};

GPBEnumDescriptor *msg_send_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL msg_send_type_IsValidValue(int32_t value);

#pragma mark - Enum msg_reply_type

typedef GPB_ENUM(msg_reply_type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  msg_reply_type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Quick reply to message */
  msg_reply_type_MsgReplyMsg = 0,

  /** Quick reply to call */
  msg_reply_type_MsgReplyCall = 1,
};

GPBEnumDescriptor *msg_reply_type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL msg_reply_type_IsValidValue(int32_t value);

#pragma mark - EnumsRoot

/**
 * Exposes the extension registry for this file.
 *
 * The base class provides:
 * @code
 *   + (GPBExtensionRegistry *)extensionRegistry;
 * @endcode
 * which is a @c GPBExtensionRegistry that includes all the extensions defined by
 * this file and all files that it depends on.
 **/
GPB_FINAL @interface EnumsRoot : GPBRootObject
@end

NS_ASSUME_NONNULL_END

CF_EXTERN_C_END

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
